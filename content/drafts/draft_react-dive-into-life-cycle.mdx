---
title: React: Dive into Life Cycle
excerpt: React: Dive into Life Cycle
---

The steps and phases of React's Components.The steps and phases of React's Components.Photo by[Alexandar Todov](https://unsplash.com/@alexandar_todov?utm_source=medium&utm_medium=referral)on[Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)
One of the factors that define a form of life is its life cycle. The common path is the origin, the development to maturity and then the inevitable end.

Within the app, elements also follow this pattern. In the React world, these elements are our Components. The component lifecycle is an ongoing process that takes place throughout the lifetime of our application.

Understanding this process can lead to faster and more consistent development, easier optimization, and better overall application health.

### The Lifecycle Steps

A lifecycle provides a specific order of operation and a series of hooks to tie into said system. The React lifecycle follows the common flow from source to end.

The lifecycle has three main stages:

- Mounting: executes once when the component is created.
- Updating: runs whenever a change is made to the component.
- Unmounting: executes once when the component is about to be destroyed.

There are also three phases, which run several times during the lifecycle:

- Render phase: is used to calculate the changes and can be aborted if the user wishes. If this phase is aborted, the DOM is not updated.
- Pre-commit phase: This is a period where you can read changes made to the VDOM, before they are applied to the real DOM.
- Commit phase: Here changes are applied and any side effects are triggered.

### Diving into a Component's Lifecycle

Mounting
The first step of the React Component lifecycle is the Mount. In this step, the Component’s props and state are defined and configured. The Component and all its children are assembled on the Native UI Stack (DOM, UIView, etc). Finally, we can do post-processing if necessary.

Step 1: The First RenderWhen we talk about the first render() (in the browser, this is the ReactDOM.render() method), it is a special version of the render() method that assembles our entire application in the Native UI.

In this first render() we pass the root Element and tell React where to assemble our content. With this call, React starts processing the passed element(s) and generating instances of our React components.

The element is used to instantiate the type and then the props are passed to the component instance.

Step 2: Inicialização e ConstruçãoDurante a inicialização, os props e o state do componente são definidos.

Step 3: Default Props

A instância Element contém as props atuais que estão sendo passadas para a instância Component. Na maioria das vezes, todas as props disponíveis no componente não são necessárias. No entanto, algumas vezes precisamos ter valores para todas elas para que nosso componente seja renderizado corretamente.

Check the code above:

```js
interface Props {
  isLoading: boolean;
  resourceData: IData;
}
```

```graf graf--pre graf-after--pre
public constructor(props: Props) {  super(props);};
```

Step 4: Initial StateUma vez que os props finais são definidos (passados com padrões), a instância Component configura o estado inicial. Esse processo ocorre na construção da própria instância. Ao contrário das props, o estado Component é um objeto interno que não é definido por valores externos.

Check the code above:

```js
// Type checking do State.interface State {  dataInfo: IDataInfo;  isLoading: boolean;  shouldVerifyData: boolean;}
```

```graf graf--pre graf-after--pre
// Chamando o Initial State.public constructor(props) {  super(props);
```

```graf graf--pre graf-after--pre
this.state = this.getInitialState();};
```

```graf graf--pre graf-after--pre
// Definindo o Initial State.private getInitialState = (): State => ({  gamificationInfo: null,  isLoading: false,  shouldVerifyGamification: true,});
```

### State defaults

É importante ter em mente que, se não definirmos um estado no construtor o estado será undefined. Como o estado é indefinido e não um Objeto vazio {}, se você tentar consultar o estado posteriormente, isso será um problema.

Em geral, queremos definir um valor padrão para todas as nossas propriedades de estado. Existem alguns casos extremos em que o valor inicial da propriedade de estado pode ser null ou undefined. Se esse estado for apenas uma propriedade de estado, pode ser tentador ignorar a configuração de um estado padrão. Mas, se nosso código tentar acessar a propriedade, vamos receber um erro.

### 3. Pre-montagem

Agora que as props e o state estão definidos, finalmente entramos no domínio dos métodos do ciclo de vida.

O getDerivedStateFromProps é o método chamado logo antes do render() e é o lugar natural para definir o estado com base nas props iniciais. Ele recebe props e state como argumentos e retorna um objeto com mudanças no estado ou um null.

O getDerivedStateFromProps veio para substituir o componentWillReceiveProps. O objetivo é atualizar o estado antes da renderização e deve ser usado com cautela. Como este é um método estático, ele não tem acesso à instância do componente. Para atualizar o estado, basta retornar um objeto simples ou null para não atualizar nada. Isso serve ao mesmo propósito que setState(), mas é executado no início do ciclo de vida.

### 4. Renderização

Com o Componente pré-montado, entramos na primeira renderização do conteúdo.

Ao contrário de qualquer outro método no ciclo de vida, o render() é o único método que existe em mais de uma fase do ciclo de vida de um componente. Ocorre aqui na Origem do componente e no seu Desenvolvimento.

Em ambos os casos, temos o princípio básico de manter render() como um método puro. E isso significa que não devemos chamar setState(), consultar a Native UI ou qualquer outra coisa que possa alterar o estado existente do aplicativo. O motivo é que, se fizermos esse tipo de interação no render(), ele iniciará outra passagem de renderização. O que, mais uma vez, aciona o render(), que faz a mesma coisa e isso se dará infinitamente.

O React também irá avisá-lo se você tentar acessar os elementos nativos da interface do usuário na passagem de renderização.

### 5. Pós-montagem

A última etapa na fase do ciclo de vida da Origem é o componentDidMount(). Esse método é chamado quando todos os nossos elementos filhos e nossas instâncias de componentes são montados na interface nativa do usuário. Quando esse método é chamado, passamos a ter acesso à interface nativa do usuário (DOM, UIView, etc.), acesso às referências de nossos componentes filhos e a capacidade de acionar um novo ciclo de renderização.

### Atualização / Desenvolvimento

Uma vez que o componente é montado na fase de Origem, o mesmo está preparado para quaisquer atualizações.

A fase de Desenvolvimento é onde um Componente passa a maior parte do tempo. Aqui temos atualizações de dados, onde atua nas ações do usuário ou do sistema e fornecemos a experiência geral para nosso aplicativo.

A fase de Desenvolvimento é acionada de três maneiras diferentes:

- mudança de props
- mudança de state com setState()
- mudança por meio do forceUpdate()

As mudanças feitas afetam como a fase de atualização é gerenciada.

### 1. Utilizando o getDerivedStateFromProps()

Ocorre da mesma forma com na pré-montagem da Origem do componente.

### 2. Utilizando o shouldComponentUpdate()

Este método é usado para interceptar o ciclo de vida da atualização.

Com este método é possível:

- Previnir renderizações desnecessárias: por meio de comparações das props e o estado atual com os próximos dados é possível decidir se é necessário uma nova renderização ou não.
- Parar as renderizações direto da fonte: até este ponto as props e o state do componente ainda não foram atualizados, ou seja, você pode acessar as props antigas usando this.props e o estado antigo usando this.state, e compará-los com os novos recebidos como argumentos.

Este método existe apenas como um fator de otimização para performance.

### 3. Re-renderização

Ocorre da mesma forma com na Renderização da Origem do componente.

### 4. Prevendo mudanças com o getSnapshotBeforeUpdate()

Este método é invocado antes que a saída renderizada mais recentemente seja confirmada. Ele permite que seu componente capture algumas informações do DOM (por exemplo, posição de rolagem) antes de ser potencialmente alterado. Qualquer valor retornado por este método de ciclo de vida será passado como um parâmetro para componentDidUpdate().

### 5. Pós-renderização com o componentDidUpdate()

O componentDidUpdate() é a versão de Desenvolvimento do componentDidMount(). Mais uma vez, podemos acessar a stack da Native UI, interagir com refs e, se necessário, iniciar outra re-renderização/atualização do componente.

Quando o componentDidUpdate() é chamado, dois argumentos são passados: prevProps e prevState.

Você também pode alterar o estado usando setState() aqui, mas deve envolvê-lo em uma condição. Como qualquer alteração no estado aciona uma nova atualização, se você não fizer nenhuma verificação, isso causará um loop infinito.

### Desmontagem / Fim

Durante esta fase, nosso componente é desmontado da Native UI Stack e enviado para o Garbage Collection.

Entramos nessa fase quando nossa interface do usuário muda e a árvore de elementos não possui mais uma chave correspondente ao nosso componente. Isso pode estar alterando o layout ou alterando as chaves programaticamente (forçando a criação de uma nova instância de componente). Quando isso ocorre, o React examina a instância que está sendo removida e seus elementos filhos também.

Assim como o resto das fases do nosso ciclo de vida, a fase Fim tem um hook. O método componentDidMount() nos permite fazer alguma limpeza (ou reverter uma ação) antes que seja removido da Native UI stack.

### Métodos descontinuado no ciclo de vida

Esses métodos foram introduzidos em versões anteriores do React e devem ser evitados.

Se a aplicação utiliza alguns destes métodos, considere remover ou renomear com o prefixo UNSAFE\_ (os nomes anteriores foram removidos na versão 17 do React), e se você pretende iniciar um novo projeto, simplesmente não os use.

### UNSAFE_componentWillMount()

- Sobre: este método é invocado logo antes da montagem.
- O que fazer: apenas mova sua lógica para o componentDidMount ou o constructor se precisar inicializar alguma coisa.

### UNSAFE_componentWillReceiveProps()

- Sobre: este método é invocado antes que um componente montado receba novas props.
- O que fazer: execute side-effects no componentDidUpdate ou getDerivedStateFromProps para atualizar o estado.

### UNSAFE_componentWillUpdate(nextProps, nextState)

- Sobre: este método é invocado entre a renderização e o componentDidUpdate .
- O que fazer: normalmente você pode mover a lógica desse método para componentDidUpdate ou, se ler do DOM, mover a lógica para getSnapshotBeforeUpdate.

### Fluxograma do ciclo de vida

O fluxograma abaixo detalha as etapas do Ciclo de Vida do React e os respectivos métodos que podem ser utilizados.

View original.

Exported from Medium on February 3, 2025.
