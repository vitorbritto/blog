---
title: Architectural Patterns
excerpt: Architectural Patterns
---

The Serverless ArchitectureThe Serverless Architecture
When your company is competing with a dozen others and you’re in a race to put out the best product features for customers, agility and speed to market matter. Decisions around technology infrastructure can be pivotal, the difference between executing your way towards product-market fit and letting your product roadmap languish. Traditionally, this involved provisioning and managing servers, a route that can be resource-intensive and costly. This is not ideal for the lean operation of a startup. As young companies strive to innovate and scale rapidly, they need systems that minimize technology management overhead and operational costs.


Against this backdrop, serverless architecture has emerged as a compelling option, promising high scalability and cost-effectiveness, without the burden of server management.


The name “serverless” is a bit of a misnomer because servers are still involved; it’s just that developers no longer need to be concerned with them. The cloud provider manages the server space, dynamically allocating resources as needed.


Serverless architecture represents a shift in how applications are built and deployed.


Unlike traditional server-based systems, serverless applications do not require the management of infrastructure. Instead, they rely on third-party services and cloud providers to handle the backend, allowing developers to focus solely on writing code. This model abstracts away server management, scaling, and infrastructure concerns, offering a more streamlined development process.


Serverless allows applications to be hostless (apps aren’t hosted on a server), stateless (interactions and data aren’t stored), elastic (resources are scaled up and down without limits), distributed (multiple services are linked for seamless functioning), and event-driven (resources are allocated only when triggered by an event).


### Principles of Serverless Architecture

Stateless Functions
In a serverless environment, functions are stateless, meaning they do not retain any data between executions. Each invocation is independent, and any necessary state must be managed externally, typically in databases or other storage solutions.

Push-Based Event-Driven Pipelines
Serverless architectures often utilize event-driven pipelines, where functions are triggered by events such as HTTP requests, database changes, or messages from a queue. This push-based model ensures that resources are used efficiently, as functions are only executed when needed.

Powerful Front-Ends
With serverless, much of the application logic can be shifted to the front-end. Modern front-end frameworks and libraries, combined with serverless backends, enable the creation of highly interactive and responsive user interfaces.

Embedding Third-Party Services
Serverless applications frequently integrate third-party services for functionality such as authentication, payments, and data storage. This approach leverages existing solutions, reducing development time and complexity.


### How Serverless Functions Operate


1. Writing code and deployment: Developers write functions in a supported language (e.g., JavaScript, Python, Go). These functions are then packaged and deployed to a serverless platform. Deployment tools and frameworks like the Serverless Framework, AWS SAM, and Terraform help manage the deployment process.
2. Event-driven invocation: Functions are invoked in response to events. When an event occurs, the serverless platform provisions the necessary resources, executes the function, and then deallocates the resources once the function completes. Functions are stateless, meaning they don’t retain any data between invocations. Any stateful data must be stored externally, typically in databases or object storage.
3. Scaling: Serverless platforms automatically scale functions horizontally by running multiple instances of the function in parallel in response to incoming events. The platform handles scaling up during high demand and scaling down during low demand, ensuring efficient resource utilization.
4. Billing: Billing in serverless architecture is based on the actual usage of resources. Users are charged for the number of requests and the execution duration of their functions. This pay-as-you-go model can result in significant cost savings, especially for applications with variable or unpredictable workloads.


### Transition from Server to Services


Transitioning from traditional server-based architectures to serverless involves rethinking how applications are designed and deployed.


Key steps include:


1. Identifying Stateless Components: Determine which parts of the application can be broken down into stateless functions.
2. Selecting Event Sources: Choose appropriate triggers for functions, such as HTTP requests or message queues.
3. Integrating Third-Party Services: Identify external services that can handle specific functionalities.
4. Refactoring Code: Modify existing code to fit the serverless model, ensuring functions are stateless and event-driven.


### Examples of Serverless Applications

UI-Driven Applications
In UI-driven applications, serverless functions can handle backend logic, such as processing form submissions or retrieving data. For instance, a serverless function can be triggered by a user submitting a form, process the data, and return a response to the front-end.

Message-Driven Applications
Message-driven applications utilize message queues to decouple components and handle asynchronous processing. Serverless functions can be triggered by messages from a queue, process the messages, and perform the necessary actions.


### Unpacking FaaS (Function as a Service)

State
In FaaS, functions are inherently stateless, meaning they do not retain data between executions. Any state that needs to be preserved must be stored externally.

Execution Duration
Serverless functions have a limited execution duration, typically ranging from a few seconds to several minutes. This limitation requires careful design to ensure that tasks are completed within the allowed time frame.

Latency and Cold Starts
Latency can be an issue in serverless environments, particularly due to cold starts. A cold start occurs when a function is invoked after being idle, causing a delay as the environment initializes. Warm starts, where functions are invoked repeatedly, experience lower latency.

API Gateways
API Gateways serve as the entry point for serverless functions, handling incoming requests and routing them to the appropriate function. They provide features such as authentication, throttling, and caching.

Tooling
A variety of tools are available to support serverless development, including frameworks like AWS Serverless Application Model (SAM), Serverless Framework, and Terraform for infrastructure as code.

Open Source
Open-source projects and tools play a significant role in the serverless ecosystem, providing solutions for monitoring, logging, and deployment.


### What is Not Serverless?

PaaS (Platform as a Service)
While PaaS solutions abstract away some infrastructure management, they do not offer the same level of abstraction as serverless architectures. Developers still need to manage scaling and runtime environments.

Containers
Containers package applications and their dependencies but require management of the container orchestration infrastructure, unlike serverless functions which abstract away infrastructure concerns completely.

NoOps
NoOps suggests the complete elimination of operational tasks, which is not feasible. Serverless reduces operational burden but does not eliminate it entirely.

Stored Procedures as a Service
Stored procedures run within a database and do not offer the same flexibility and scalability as serverless functions.


### Serverless Architectures

Compute as Back-End
In this model, serverless functions handle backend logic and data processing, while front-end applications interact with these functions via API calls.

Legacy API Proxy
Serverless functions can act as proxies for legacy APIs, allowing modern applications to interact with older systems without direct integration.

Hybrid
Hybrid architectures combine serverless functions with traditional server-based components, providing a balance between flexibility and control.

GraphQL
Serverless functions can be used to implement GraphQL resolvers, enabling flexible and efficient data querying.

Compute as Glue
Serverless functions can act as glue code, connecting various services and components within an application.

Real-Time Processing
Serverless architectures can handle real-time data processing tasks, such as streaming data from IoT devices or processing user interactions.


### Patterns in Serverless Architecture

Command Pattern
The command pattern encapsulates a request as an object, allowing parameterization and queuing of requests.


```mermaidgraph TD; Invoker →Command; Command →Receiver;```

Messaging Pattern
Messaging patterns enable communication between different parts of a system through messages.


```mermaidgraph TD; Sender →Queue; Queue →Receiver;```

Priority Queue Pattern
A priority queue pattern processes messages based on priority, ensuring important tasks are handled first.


```mermaidgraph TD; HighPriority →Queue; LowPriority →Queue; Queue →Worker;```

Fan-Out Pattern
The fan-out pattern distributes messages to multiple recipients, enabling parallel processing.


```mermaidgraph TD; Event →Function1; Event →Function2; Event →Function3;```

Pipes and Filters Pattern
The pipes and filters pattern breaks down processing into a series of steps, each performed by a different function.


```mermaidgraph TD; Input →Filter1; Filter1 →Filter2; Filter2 →Filter3; Filter3 →Output;```


### Benefits


- **Cost Efficiency**: Pay only for actual usage, reducing idle resource costs.- **Scalability**: Automatic scaling based on demand, without manual intervention.- **Reduced Operational Overhead**: Managed infrastructure and services handle scaling, patching, and availability.- **Faster Development**: Focus on code rather than infrastructure, accelerating development cycles.


### Drawbacks


- **Cold Starts**: Latency introduced by cold starts can impact performance.- **Vendor Lock-In**: Reliance on specific cloud providers and their services can limit flexibility.- **Complexity**: Managing multiple services and integrating them can increase complexity.- **Debugging and Monitoring**: Difficulties in local development, testing, and monitoring distributed functions.


### The Future of Serverless


The future of serverless looks promising, with ongoing advancements in tooling, performance optimization, and integration capabilities. As the ecosystem matures, more use cases will emerge, making serverless a viable option for an even broader range of applications.


### Conclusion


Serverless architecture offers a transformative approach to building and deploying applications. By abstracting away infrastructure management, it allows developers to focus on writing code and delivering value. While there are challenges and trade-offs, the benefits of cost efficiency, scalability, and reduced operational overhead make serverless an attractive option for modern application development. As the technology evolves, serverless is set to play a significant role in the future of software architecture.


View original.


Exported from Medium on February 3, 2025.

