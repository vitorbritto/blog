---
title: The Package by Feature approach
excerpt: The Package by FeatureÂ approach
---

How it can help you build scalable and manageable projects.How it can help you build scalable and manageable projects.Photo by[BoliviaInteligente](https://unsplash.com/@boliviainteligente?utm_source=medium&utm_medium=referral)on[Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

### Introduction

Modularization is the process in software development that involves breaking down a system into smaller, manageable, and independent components or modules to improve maintainability and reusability.

Let's dive into some techniques. ğŸš€

### Package byÂ layer

The Package by Layer structure is an architectural design pattern used in software development that organizes code files into separate layers, with each layer representing a specific functionality or responsibility within the application. Typically, these layers include the presentation layer (user interface), application layer (business logic), domain layer (domain-specific logic), and infrastructure layer (database and external services).

Check the example bellow.

```js
.â”œâ”€â”€ srcâ”‚   â”œâ”€â”€ controllersâ”‚   â”œâ”€â”€  â”œâ”€â”€ CompanyControllerâ”‚   â”œâ”€â”€  â”œâ”€â”€ CustomerControllerâ”‚   â”œâ”€â”€  â””â”€â”€ ProductControllerâ”‚   â”œâ”€â”€ entitiesâ”‚   â”œâ”€â”€  â”œâ”€â”€ CompanyEntityâ”‚   â”œâ”€â”€  â”œâ”€â”€ CustomerEntityâ”‚   â”œâ”€â”€  â””â”€â”€ ProductEntityâ”‚   â”œâ”€â”€ repositoriesâ”‚   â”œâ”€â”€  â”œâ”€â”€ CompanyRepositoryâ”‚   â”œâ”€â”€  â”œâ”€â”€ CustomerRepositoryâ”‚   â”œâ”€â”€  â””â”€â”€ ProductRepositoryâ”‚   â”œâ”€â”€ servicesâ”‚   â”œâ”€â”€  â”œâ”€â”€ CompanyServiceâ”‚   â”œâ”€â”€  â”œâ”€â”€ CustomerServiceâ”‚   â”œâ”€â”€  â””â”€â”€ ProductServiceâ”‚   â”œâ”€â”€ dtosâ”‚   â”œâ”€â”€  â”œâ”€â”€ CompanyDTOâ”‚   â”œâ”€â”€  â”œâ”€â”€ CustomerDTOâ”‚   â”œâ”€â”€  â””â”€â”€ ProductDTOâ”‚   â”œâ”€â”€ daosâ”‚   â”œâ”€â”€  â”œâ”€â”€ CompanyDAOâ”‚   â”œâ”€â”€  â”œâ”€â”€ CustomerDAOâ”‚   â”œâ”€â”€  â””â”€â”€ ProductDAOâ””â”€â”€ â””â”€â”€ utils
```

The problems behind thisÂ approach
This approach brings some problems, including the high coupling and low cohesion.

Cohesion: It refers to the degree of logical relationship of package members to each other. High relationship between members ensures package independence. Low cohesion not only reduces independence but also significantly reduces reusability and understandability.

Coupling: It refers to the degree of interdependence between packages/classes. Low coupling significantly increases maintainability. How? Since changes made within a class due to the requirements will not affect other classes, side effects do not occur and maintenance becomes easier.

Also, we have a poor overview of all classes that belong to a feature and tendency to generic, reused and complex code, which is hard to understand and changes can easily break other use cases as the impact of a change is hard to grasp.

### Package byÂ feature

In this project structure, packages contain all classes that are required for a feature. The independence of the package is ensured by placing closely related classes in the same package. An example of this structure is given below:

```js
.â”œâ”€â”€ srcâ”‚   â”œâ”€â”€ companyâ”‚   â”œâ”€â”€  â”œâ”€â”€ CompanyControllerâ”‚   â”œâ”€â”€  â”œâ”€â”€ CompanyEntityâ”‚   â”œâ”€â”€  â”œâ”€â”€ CompanyRepositoryâ”‚   â”œâ”€â”€  â”œâ”€â”€ CompanyServiceâ”‚   â”œâ”€â”€  â”œâ”€â”€ CompanyDTOâ”‚   â”œâ”€â”€  â””â”€â”€ CompanyDAOâ”‚   â”œâ”€â”€ customerâ”‚   â”œâ”€â”€  â”œâ”€â”€ CustomerControllerâ”‚   â”œâ”€â”€  â”œâ”€â”€ CustomerEntityâ”‚   â”œâ”€â”€  â”œâ”€â”€ CustomerRepositoryâ”‚   â”œâ”€â”€  â”œâ”€â”€ CustomerServiceâ”‚   â”œâ”€â”€  â”œâ”€â”€ CustomerDTOâ”‚   â”œâ”€â”€  â””â”€â”€ CustomerDAOâ”‚   â”œâ”€â”€ productâ”‚   â”œâ”€â”€  â”œâ”€â”€ ProductControllerâ”‚   â”œâ”€â”€  â”œâ”€â”€ ProductEntityâ”‚   â”œâ”€â”€  â”œâ”€â”€ ProductRepositoryâ”‚   â”œâ”€â”€  â”œâ”€â”€ ProductServiceâ”‚   â”œâ”€â”€  â”œâ”€â”€ ProductDTOâ”‚   â”œâ”€â”€  â””â”€â”€ ProductDAOâ””â”€â”€ â””â”€â”€ utils
```

This structure removes the need for one packageâ€™s class to rely on another packageâ€™s class. It also ensures that the classes in the packages have strong associations with each other. Thus, there is high cohesion within packages and low coupling between packages.

In addition, this structure provides higher modularity. But how?

Letâ€™s assume there are 10 more domains, not just Company, Product and Customer. In the Package by Layer, Controllers, Services, and Repositories are placed in different single packages, so the whole application consists of three packagesâ€Šâ€”â€Šexcept utilsâ€Šâ€”â€Šand packages have a large number of members. However, in the Package by Feature style, the same application consists of 13 packages and thus, modularity is increased.

If a feature can be deleted in a single action, the application has maximum modularity.Advantages

- Package by Feature has packages with high cohesion, low coupling and high modularity.
- Package by Feature allows some classes to set their access modifier package-private instead of public, so it increases encapsulation. On the other hand, Package by Layer forces you to set nearly all classes public.
- Package by Feature reduces the need to navigate between packages since all classes needed for a feature are in the same package.
- Package by Feature is like microservice architecture. Each package is limited to classes related to a particular feature. On the other hand, Package By Layer is monolithic. As an application grows in size, the number of classes in each package will increase without bound.
- Package by Feature offers better discoverability and overview from the domain point of view. Most of the code that belongs to a business feature is located together. This is crucial because we are approaching a codebase usually with a certain business requirement in mind.
- Most of the code that a feature needs, is located in the package. So we are avoiding dependencies to other feature packages.
- As we are avoiding generic and abstracted code, the code becomes simpler because it only has to handle a single use-case. Hence, itâ€™s easier to understand and to evolve the code.
- Usually, a class in a feature package has fewer dependencies compared to a â€œgod-classâ€ in a technical package that tries to fulfill all use-cases. So testing becomes easier as we have to create less test fixture.

### The commonÂ things

One point of attention is the shared resources, like the utils directory, which contains files shared across the application. This is where we will have components, utilities, constants, and other resources that can be part of one or more features.

### Conclusion

The Package by Feature makes the development process more organized and scalable, as each module can be developed, tested, and maintained independently. Additionally, the modularization promotes code reusability, simplifies debugging, and facilitates collaboration among team members, leading to increased overall productivity and efficiency.

### References

MonolithFirst (Martin Fowler): https://www.martinfowler.com/bliki/MonolithFirst.html

Presentation Domain Data Layering (Martin Fowler):https://martinfowler.com/bliki/PresentationDomainDataLayering.html

Vertical Slice Architecture (Jimmy Bogard):https://www.jimmybogard.com/vertical-slice-architecture/

Modular monoliths (Simon Brown):Â https://youtu.be/5OjqD-ow8GE

Thanks for reading. If you have any thoughts or suggestions, feel free to leave a comment below.

You can follow me on TwitterÂ , Github and LinkedIn.

See you! ğŸ‘‹

By Vitor Britto on November 7, 2023.

Canonical link

Exported from Medium on February 3, 2025.
